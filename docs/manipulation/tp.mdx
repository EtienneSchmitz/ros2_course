---
sidebar_position: 3
---

# ğŸ› ï¸ Travaux pratique

## ğŸ§  Partie 1 â€” Comprendre la reprÃ©sentation dâ€™un robot sous ROSÂ 2

Un robot intÃ©grÃ© dans lâ€™Ã©cosystÃ¨me ROSÂ 2 est constituÃ© au minimum de deux Ã©lÃ©ments essentiels :

- ğŸ”§ Un descripteur URDF (Unified Robot Description Format) qui dÃ©crit la structure du robot (liens, joints, dimensionsâ€¦)
- ğŸ§  Un contrÃ´leur qui permet dâ€™interagir avec les capteurs et actionneurs du robot

### ğŸ” 1. Visualisation et comprÃ©hension du descripteur URDF

Pour gÃ©nÃ©rer et visualiser la structure du robot OpenMANIPULATOR-X, suivez les Ã©tapes suivantes :

#### ğŸ› ï¸ GÃ©nÃ©ration du fichier URDF

ğŸ’» Dans un terminal, exÃ©cutez :
```bash
ros2 run xacro xacro $HOME/ros2_ws/src/open_manipulator/open_manipulator_description/urdf/om_x/open_manipulator_x.urdf.xacro -o /tmp/open_manipulator_x.urdf
```

#### ğŸ“ˆ GÃ©nÃ©ration de la visualisation de lâ€™arbre URDF

Ensuite, convertissez le fichier en une reprÃ©sentation graphique :
```bash
urdf_to_graphiz /tmp/open_manipulator_x.urdf
```

Un fichier PDF sera gÃ©nÃ©rÃ© dans le rÃ©pertoire courant. Vous pouvez lâ€™ouvrir avec un visualiseur PDF :
```bash
evince open_manipulator_x.urdf.pdf
``` 

Cela vous permettra dâ€™observer lâ€™arbre des liens et des articulations du robot, utile pour comprendre la cinÃ©matique du bras.

### ğŸ¤– 2. Visualisation 3D du robot et de ses articulations

Pour visualiser un modÃ¨le interactif du robot dans RViz (ou dans un visualiseur 3D similaire), lancez le fichier suivant :

```bash
 ros2 launch open_manipulator_description model_x.launch.py 
```
Cette commande :
- ğŸ“¦ Charge la description URDF du robot
- ğŸ§© Initialise les nÅ“uds nÃ©cessaires Ã  la visualisation
- ğŸ–¼ï¸ Affiche le robot dans RViz
- ğŸ›ï¸ Permet de manipuler les joints du robot via des sliders ou par lâ€™envoi de messages ROS

#### ğŸ“¡ 2.a. Explorer les topics publiÃ©s par le robot

Ã€ lâ€™aide de la commande ros2 topic, explorez les communications du robot.
- Quel est le nom du topic qui publie lâ€™Ã©tat courant des articulations (positions, vitesses, efforts) ?
- Quel est le type du message transmis par ce topic ?
- Ã€ quelle frÃ©quence (en Hz) le robot met-il Ã  jour lâ€™Ã©tat de ses joints ?

#### ğŸ“ˆ 2.b. Tracer la courbe des positions des moteurs en temps rÃ©el

##### ğŸ”¹ Option 1 â€” Avec `rqt_plot`

Lancez lâ€™outil de visualisation graphique intÃ©grÃ© Ã  ROSÂ 2 :
```bash
ros2 run rqt_plot rqt_plot
```

Dans le champ de saisie, entrez le nom du topic que vous souhaitez tracer. Pour les positions articulaires, utilisez : 
`/joint_states/position[<indice_du_joint>]`

> ğŸ”¢ Lâ€™indice dÃ©pend de lâ€™ordre des joints dans le message JointState. Par exemple, si joint3 est le quatriÃ¨me Ã©lÃ©ment, utilisez position[3].

##### ğŸ”¹ Option 2 â€” Avec `PlotJuggler`

PlotJuggler offre une interface plus puissante et interactive. Pour lâ€™installer :
```bash
sudo apt install ros-jazzy-plotjuggler ros-jazzy-plotjuggler-ros
```
Ensuite :
1. Lancez PlotJuggler depuis votre terminal :
```bash
ros2 run plotjuggler plotjuggler
```
2. Dans lâ€™onglet **Streaming**, cliquez sur ROS Topic Subscriber et sÃ©lectionnez `/joint_states`, puis appuyez sur Start.

3. Faites glisser les positions des joints sur le graphique pour les visualiser en temps rÃ©el.

4. Bougez avec les sliders pour observer lâ€™Ã©volution des valeurs en temps rÃ©el.

---

## ğŸ§  Partie 2 â€” Manipulation du robot OpenManipulator-X

### 0. Lancement du robot dans Gazebo

Pour simuler le robot dans lâ€™environnement physique **Gazebo**, utilisez la commande suivante :
```bash
ros2 launch open_manipulator_bringup gazebo.launch.py
``` 

Vous devriez voir le robot **OpenManipulator-X** apparaÃ®tre dans la scÃ¨ne Gazebo, prÃªt Ã  Ãªtre manipulÃ©.

> **Remarque** : Gardez **Gazebo ouvert** en permanence pour les manipulations Ã  venir.

### 1. MoveIt avec RViz : planification et exÃ©cution

> ğŸ”„ Cela lance Gazebo avec le robot dÃ©jÃ  placÃ© dans la scÃ¨ne, prÃªt Ã  Ãªtre manipulÃ©.

:::tip Astuce : TÃ©lÃ©opÃ©ration
Vous pouvez contrÃ´ler le robot via le clavier avec cette commande :
```bash
ros2 run open_manipulator_teleop keyboard_control_x.py
```
:::

#### ğŸ¤– Lancement de MoveIt (planification de mouvement)

Pour utiliser MoveIt avec le robot OpenManipulator-X, exÃ©cutez :
```bash
ros2 launch open_manipulator_moveit_config moveit.launch.py
```

Cela ouvre RViz avec MoveIt configurÃ© et prÃªt Ã  planifier les mouvements du bras manipulateur.

#### ğŸ® Interaction avec MoveIt dans RViz


Dans RViz et dans lâ€™onglet **MotionPlanning**, vous pouvez interagir avec le robot de la maniÃ¨re suivante :
1. SÃ©lectionnez le planning group `arm`.
2. DÃ©placez la sphÃ¨re bleue (goal position/orientation).
3. Cliquez sur `Plan` pour gÃ©nÃ©rer une trajectoire.
4. Cliquez sur `Execute` pour exÃ©cuter le mouvement.

:::tip ğŸ’¡ Astuce
Le bouton `Plan and Execute` permet de faire les deux Ã©tapes en un seul clic.
:::

> ğŸ§ª Explorez :
> - Le dÃ©placement du bras du robot en manipulant la sphÃ¨re bleue.
> - Le changement de goal state.
> - La modification des joints dans lâ€™onglet Joint States.

##### â“ Questions dâ€™observation

- ğŸ”˜ Que reprÃ©sente le robot gris, parfois mobile mais lent ?
- ğŸ”¸ Que reprÃ©sente le robot orange (fixe) ?
- ğŸ” Que reprÃ©sente le robot gris qui rÃ©pÃ¨te un mouvement rapide ?

#### âœ‹ Tester la planification du gripper
 
Vous pouvez aussi planifier le mouvement du gripper via MoveIt :

##### ğŸ“Œ Ã‰tapes :
1. Dans lâ€™onglet **Planning**, section **Query** :
2. DÃ©finissez le `Start state` sur `current`.
3. DÃ©finissez le `Goal state` sur un Ã©tat du gripper (ouvert / fermÃ©).
4. SÃ©lectionnez le planning group `gripper`.
5. Cliquez sur `Plan`, puis `Execute`.

##### â“ Questions de comprÃ©hension

- ğŸ§© Quelle est la diffÃ©rence entre les groupes `arm` et `gripper` ?
- ğŸ¯ Qu'est-ce quâ€™un planning group dans MoveIt ?
    - Ã€ quoi cela sert-il ?
    - Pourquoi en existe-t-il plusieurs ?

### 2. ğŸŒ Visualisation et interrogation de lâ€™arbre des transformations (tf)

ğŸ’» Ã‰tapes :
1. Lancez MoveIt.
2. Dans un nouveau terminal, exÃ©cutez la commande suivante :
```bash
ros2 run tf2_tools view_frames
```
Cela gÃ©nÃ¨re un fichier frames.pdf reprÃ©sentant lâ€™arbre des repÃ¨res (frames) du robot.

ğŸ” Ce fichier montre les mÃªmes repÃ¨res que ceux affichÃ©s en rouge-vert-bleu dans RViz. Chaque repÃ¨re correspond Ã  un Ã©lÃ©ment du robot ou de la scÃ¨ne.

â“ Questions
- Quel est le nom du repÃ¨re de base du robot ?
- Quels sont les noms des deux repÃ¨res correspondant aux effecteurs finaux possibles ?
- Quelle est la position actuelle dâ€™un des effecteurs par rapport au repÃ¨re de base ?

ğŸ’¡ Pour cela, utilisez la commande suivante (en remplaÃ§ant les noms de repÃ¨res) :
```bash
ros2 run tf2_ros tf2_echo <repÃ¨re_base> <repÃ¨re_effecteur>
```

> Cette commande affiche la transformation (position et orientation) du repÃ¨re de lâ€™effecteur dans celui de base.
> Vous pouvez noter les coordonnÃ©es de position pour les utiliser ensuite comme cible de planification dans MoveIt.

### 3. MoveIt avec Python : planification et exÃ©cution


```python
from geometry_msgs.msg import PoseStamped
from moveit_commander import PlanningSceneInterface, MoveGroupCommander
import rclpy
import time

rclpy.init()
scene = PlanningSceneInterface()
group = MoveGroupCommander("arm")

time.sleep(2)  # Attente pour connexion Ã  RViz

# Ajouter un cube
cube_pose = PoseStamped()
cube_pose.header.frame_id = "world"
cube_pose.pose.position.x = 0.4
cube_pose.pose.position.y = 0.0
cube_pose.pose.position.z = 0.025
scene.add_box("cube", cube_pose, size=(0.05, 0.05, 0.05))

# Aller au-dessus du cube
pose = group.get_current_pose().pose
pose.position.x = 0.4
pose.position.y = 0.0
pose.position.z = 0.1
group.set_pose_target(pose)
group.go(wait=True)
group.clear_pose_targets()

# Descendre
pose.position.z = 0.045
group.set_pose_target(pose)
group.go(wait=True)
group.clear_pose_targets()

# Attacher le cube
scene.attach_box(group.get_end_effector_link(), "cube")
```
