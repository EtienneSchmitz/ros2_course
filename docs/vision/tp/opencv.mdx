---
sidebar_position: 1
sidebar_label: "ğŸ–¼ï¸ OpenCV"
---

# ğŸ–¼ï¸ Vision par ordinateur avec OpenCV

La **vision par ordinateur** (ou *Computer Vision*, CV) est une branche de l'intelligence artificielle qui vise Ã  extraire automatiquement des informations pertinentes Ã  partir dâ€™images.  
DÃ©veloppÃ© depuis les annÃ©es 1960, ce domaine combine des techniques issues des **mathÃ©matiques**, du **traitement dâ€™images**, des **neurosciences**, et de lâ€™**apprentissage automatique**.

Dans ce TP, vous allez dÃ©couvrir **OpenCV**, une bibliothÃ¨que de rÃ©fÃ©rence, et apprendre Ã  dÃ©tecter des **objets colorÃ©s** dans une image.  
ğŸ‘‰ Objectif final : **dÃ©tecter les positions des cubes colorÃ©s et exposer les rÃ©sultats dans un nÅ“ud ROS 2.**

---

## 1. ğŸš€ Introduction Ã  OpenCV

**OpenCV** est une bibliothÃ¨que open-source offrant de nombreuses fonctionnalitÃ©s en vision par ordinateur :

- Chargement et manipulation dâ€™images et de flux vidÃ©o (webcams, fichiers, etc.)
- Traitement dâ€™image : conversion de couleur, filtrage, dÃ©tection de contours...
- AccÃ¨s Ã  des milliers dâ€™algorithmes utilisÃ©s dans l'industrie (dÃ©tection de visages, suivi dâ€™objets, etc.)

ğŸ“š Tutoriel complet : [OpenCV Python Tutorials](https://docs.opencv.org/4.11.0/d6/d00/tutorial_py_root.html)

---

## 2. ğŸ–¼ï¸ Ouverture et affichage dâ€™une image

1. TÃ©lÃ©chargez lâ€™image suivante :  ![](/img/vision/cubes.jpg)
   
2. CrÃ©ez un fichier `couleurs.py` :

    ```python
    import numpy as np
    import cv2 as cv

    img = cv.imread('cubes.jpg')
    ```

3. Testez :

    ```python
    print(img.shape)
    ```

â“ Que reprÃ©sentent les trois valeurs renvoyÃ©es ?

4. Vous pouvez accÃ©der Ã  un pixel par :

    ```python
    print(img[170, 255])  # [B, G, R]
    ```

5. Pour isoler un canal (Bleu = 0, Vert = 1, Rouge = 2) :

    ```python
    canal_rouge = img[:, :, 2]
    ```

6. Pour extraire une **rÃ©gion dâ€™intÃ©rÃªt (ROI)** :

    ```python
    roi = img[140:225, 210:310]
    ```

7. Pour afficher une image :

    ```python
    cv.imshow("Mon image", roi)
    cv.waitKey(0)
    ```

8. Pour sauvegarder une image :

    ```python
    cv.imwrite("roi.png", roi)
    ```

ğŸ¯ **Exercice :** affichez les trois canaux de lâ€™image dans des fenÃªtres sÃ©parÃ©es.

---

## 3. ğŸ¯ DÃ©tection de couleur avec seuil HSV

Les images sont en gÃ©nÃ©ral en format `BGR`, mais ce nâ€™est pas adaptÃ© Ã  la dÃ©tection de couleurs.  
On prÃ©fÃ¨re utiliser lâ€™espace **HSV** (*Teinte, Saturation, Valeur*) :

### 1. Conversion BGR â†’ HSV

```python
img_HSV = cv.cvtColor(img, cv.COLOR_BGR2HSV)
```

> H $\in$ [0, 179], S $\in$ [0, 255], V $\in$ [0, 255]

### 2. Application dâ€™un seuil de couleur

```python
img_seuil = cv.inRange(img_HSV, (MIN_H, MIN_S, MIN_V), (MAX_H, MAX_S, MAX_V))
```

> ğŸ” img_seuil est une image binaire (pixels blancs = zone dÃ©tectÃ©e)

ğŸ¯ Exercice : dÃ©tectez le cube rouge en trouvant les bons seuils HSV.

ğŸ› ï¸ Astuce : utilisez des trackbars pour rÃ©gler les seuils en temps rÃ©el [Tutoriel OpenCV - Trackbar](https://docs.opencv.org/4.11.0/d9/dc8/tutorial_py_trackbar.html)


### 3. ğŸ” DÃ©tection des cubes dans lâ€™image

Une fois la couleur dÃ©tectÃ©e, il faut localiser les objets (les cubes).

#### 1. Recherche des contours

On commence par extraire les contours depuis lâ€™image seuillÃ©e :

```python
contours, _ = cv.findContours(
    img_seuil, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE)
```

#### 2. ğŸ¯ Filtrage des contours par surface

Tous les contours dÃ©tectÃ©s ne correspondent pas forcÃ©ment Ã  des objets utiles. Certains sont :
- Trop petits â†’ bruit
- Trop grands â†’ bord dâ€™image, ombresâ€¦  

On filtre donc les contours selon leur surface :
```python
for cnt in contours:
    area = cv.contourArea(cnt)
    if MIN_AREA < area < MAX_AREA:
        cv.drawContours(img, [cnt], -1, (0, 255, 0), 2)
```

> Cette Ã©tape permet de ne conserver que les objets ayant une taille pertinente, en rejetant les artefacts et structures parasites.

#### 3. Calcul du centre du cube

On calcule ensuite le centre gÃ©omÃ©trique de chaque contour valide (via les moments dâ€™image) :


```python
def trouver_centroid(cnt):
    M = cv.moments(cnt)
    if M['m00'] > 0:
        cx = int(M['m10']/M['m00'])
        cy = int(M['m01']/M['m00'])
        return (cx, cy)
    return (0, 0)
```

#### 4. Annotation du cube

On affiche un label "cube" au centre de chaque objet dÃ©tectÃ© :

```python
cv.putText(img, 'cube', (cx, cy), cv.FONT_HERSHEY_SIMPLEX,
           1, (255, 255, 255), 1, cv.LINE_AA)
```

ğŸ¯ Exercice : Ã©tendez votre programme pour dÃ©tecter les cubes de lâ€™image (avec des seuils adaptÃ©s pour chaque couleur).

## 4. ğŸ¤– IntÃ©gration avec ROS 2

Vous allez maintenant encapsuler votre dÃ©tection dans un nÅ“ud ROSÂ 2 sous forme de service.

##### ğŸ”§ Objectif

Ce service doit :
- Prendre en entrÃ©e une image ou une camera (en fonction de votre choix).
- Retourner une liste des positions et labels des cubes dÃ©tectÃ©s

##### ğŸ§ª Bonus : 

Faites Ã©voluer votre service pour :
- Publier la position du cube dÃ©tectÃ©
- Communiquer cette position Ã  un autre nÅ“ud ROS (ex. MoveIt, navigationâ€¦)
